##工厂模式

###动机

工厂模式可能是现代语言像Java和C#中使用最多的设计模式。有许多的变体和实现。如果你正在搜索工厂模式，很可能你会找到GoF 的：工厂方法和抽像
工厂。

###意图：
> 创建对象但不用暴露实例化逻辑
> 通过一个通用接口引用最新创建的对象

###实现

实现很简单：
> 当我们需要一个product对象，不是同new操作符直接创建，而是向对象工厂请求一个新的product对象，只需提供这种对象类型所需的信息。
> 工厂实例化一个新的product对象，然后返回给使用者。
> 使用者使用product对象作为抽象对象而不用关心它的具体实现。

###应用/例子

####switch/case 实现

>代码见SimpleProductFactory

这种实现很简单。这有个问题就是一旦我们需要新增一种具体的product我们就需要修改工厂类。这就不灵活了并且也违背了**开闭原则** 。当然我们也
可以继承工厂类，但是不要忘记工厂类一般都是作为一个单例。子类化就意味着需要替换代码中所有的工厂类引用。

####使用反射-类注册

> 代码见ReflectionProductFactory

这种反射实现方式也有它的不足。最主要的不足是性能问题。使用反射的代码的性能比不使用反射的代码性能会低%10左右。另外一个问题是不是所有的编程
语言都提供反射机制。

####不使用反射-类注册

> 代码见InstanceProductFactory

当需要添加新的product时类注册的方式不需要修改工厂类，这明显是一个灵活的解决方案。

上面的简单实现是一个**开闭原则** 的坏例子。我们最直接的解决方案是继承它来避免修改工厂方法。

####总结

当我们设计系统的时候需要考虑是否真的需要一个工厂创建对象。可能这会引入不必要的复杂性到应用中。如果我们有需要基本类型的对象并且我们需要把
它们强转为抽象类型，这时候就需要一个工厂了。如果代码里有许多类似下面的代码，也应该考虑下工厂模式：

```
(if (ConcreteProduct)genericProduct typeof )
	((ConcreteProduct)genericProduct).doSomeConcreteOperation().
```

如果决定使用工厂模式，推荐是类注册的实现方式，而不推荐swtich-case的实现方式。